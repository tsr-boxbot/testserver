diff --git a/src/SHA1.c b/src/SHA1.c
index 3ef07d9..35fd2c0 100644
--- a/src/SHA1.c
+++ b/src/SHA1.c
@@ -20,7 +20,7 @@
 #if defined(_WIN32) || defined(_WIN64)
 #pragma comment(lib, "crypt32.lib")
 
-int SHA1_Init(SHA_CTX *c)
+int SHA1_Init_paho_mqtt(SHA_CTX *c)
 {
 	if (!CryptAcquireContext(&c->hProv, NULL, NULL,
 		PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
@@ -33,7 +33,7 @@ int SHA1_Init(SHA_CTX *c)
 	return 1;
 }
 
-int SHA1_Update(SHA_CTX *c, const void *data, size_t len)
+int SHA1_Update_paho_mqtt(SHA_CTX *c, const void *data, size_t len)
 {
 	int rv = 1;
 	if (!CryptHashData(c->hHash, data, (DWORD)len, 0))
@@ -41,7 +41,7 @@ int SHA1_Update(SHA_CTX *c, const void *data, size_t len)
 	return rv;
 }
 
-int SHA1_Final(unsigned char *md, SHA_CTX *c)
+int SHA1_Final_paho_mqtt(unsigned char *md, SHA_CTX *c)
 {
 	int rv = 0;
 	DWORD md_len = SHA1_DIGEST_LENGTH;
@@ -74,7 +74,7 @@ static unsigned char pad[64] = {
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
 
-int SHA1_Init(SHA_CTX *ctx)
+int SHA1_Init_paho_mqtt(SHA_CTX *ctx)
 {
 	int ret = 0;
 	if ( ctx )
@@ -136,7 +136,7 @@ static void SHA1_ProcessBlock(SHA_CTX *ctx)
 		ctx->h[i] += blks[i];
 }
 
-int SHA1_Final(unsigned char *md, SHA_CTX *ctx)
+int SHA1_Final_paho_mqtt(unsigned char *md, SHA_CTX *ctx)
 {
 	int i;
 	int ret = 0;
@@ -151,7 +151,7 @@ int SHA1_Final(unsigned char *md, SHA_CTX *ctx)
 	else
 		pad_amount = 64 + 56 - ctx->size;
 
-	SHA1_Update(ctx, pad, pad_amount);
+	SHA1_Update_paho_mqtt(ctx, pad, pad_amount);
 
 	ctx->w[14] = htobe32((uint32_t)(total >> 32));
 	ctx->w[15] = htobe32((uint32_t)total);
@@ -170,7 +170,7 @@ int SHA1_Final(unsigned char *md, SHA_CTX *ctx)
 	return ret;
 }
 
-int SHA1_Update(SHA_CTX *ctx, const void *data, size_t len)
+int SHA1_Update_paho_mqtt(SHA_CTX *ctx, const void *data, size_t len)
 {
 	while ( len > 0 )
 	{
@@ -229,9 +229,9 @@ int main(int argc, char *argv[])
 		char out[SHA1_DIGEST_LENGTH * 2 + 1];
 		SHA_CTX c;
 		int j;
-		r[0] = SHA1_Init( &c );
-		r[1] = SHA1_Update( &c, test_data[i].in, strlen(test_data[i].in));
-		r[2] = SHA1_Final( sha_out, &c );
+		r[0] = SHA1_Init_paho_mqtt( &c );
+		r[1] = SHA1_Update_paho_mqtt( &c, test_data[i].in, strlen(test_data[i].in));
+		r[2] = SHA1_Final_paho_mqtt( sha_out, &c );
 		for ( j = 0u; j < SHA1_DIGEST_LENGTH; ++j )
 			snprintf( &out[j*2], 3u, "%02x", sha_out[j] );
 		out[SHA1_DIGEST_LENGTH * 2] = '\0';
diff --git a/src/SHA1.h b/src/SHA1.h
index 3ae2f0a..8774a3c 100644
--- a/src/SHA1.h
+++ b/src/SHA1.h
@@ -57,10 +57,10 @@ typedef struct SHA_CTX_S {
  *
  * @param[in,out]  ctx                 hashing context structure
  *
- * @see SHA1_Update
- * @see SHA1_Final
+ * @see SHA1_Update_paho_mqtt
+ * @see SHA1_Final_paho_mqtt
  */
-int SHA1_Init(SHA_CTX *ctx);
+int SHA1_Init_paho_mqtt(SHA_CTX *ctx);
 
 /**
  * Updates a block to the SHA1 hash
@@ -69,10 +69,10 @@ int SHA1_Init(SHA_CTX *ctx);
  * @param[in]      data                block of data to hash
  * @param[in]      len                 length of block to hash
  *
- * @see SHA1_Init
- * @see SHA1_Final
+ * @see SHA1_Init_paho_mqtt
+ * @see SHA1_Final_paho_mqtt
  */
-int SHA1_Update(SHA_CTX *ctx, const void *data, size_t len);
+int SHA1_Update_paho_mqtt(SHA_CTX *ctx, const void *data, size_t len);
 
 /**
  * Produce final SHA1 hash
@@ -81,10 +81,10 @@ int SHA1_Update(SHA_CTX *ctx, const void *data, size_t len);
  *                                     @p SHA1_DIGEST_LENGTH in length)
  * @param[in,out]  ctx                 hashing context structure
  *
- * @see SHA1_Init
- * @see SHA1_Final
+ * @see SHA1_Init_paho_mqtt
+ * @see SHA1_Final_paho_mqtt
  */
-int SHA1_Final(unsigned char *md, SHA_CTX *ctx);
+int SHA1_Final_paho_mqtt(unsigned char *md, SHA_CTX *ctx);
 
 #endif /* if defined(OPENSSL) */
 #endif /* SHA1_H */
diff --git a/src/WebSocket.c b/src/WebSocket.c
index 09254f4..e86b12f 100644
--- a/src/WebSocket.c
+++ b/src/WebSocket.c
@@ -1326,9 +1326,9 @@ int WebSocket_upgrade( networkHandles *net )
 
 		/* calculate the expected websocket key, expected from server */
 		snprintf( ws_key, sizeof(ws_key), "%s%s", net->websocket_key, ws_guid );
-		SHA1_Init( &ctx );
-		SHA1_Update( &ctx, ws_key, strlen(ws_key));
-		SHA1_Final( sha_hash, &ctx );
+		SHA1_Init_paho_mqtt( &ctx );
+		SHA1_Update_paho_mqtt( &ctx, ws_key, strlen(ws_key));
+		SHA1_Final_paho_mqtt( sha_hash, &ctx );
 		Base64_encode( ws_key, sizeof(ws_key), sha_hash, SHA1_DIGEST_LENGTH );
 
 		read_buf = WebSocket_getRawSocketData( net, 12u, &rcv, &rc);
